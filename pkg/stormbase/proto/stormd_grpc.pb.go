// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.4
// source: stormd.proto

package stormdpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	StormDaemon_WorkloadList_FullMethodName        = "/stormd.StormDaemon/WorkloadList"
	StormDaemon_WorkloadStart_FullMethodName       = "/stormd.StormDaemon/WorkloadStart"
	StormDaemon_WorkloadStop_FullMethodName        = "/stormd.StormDaemon/WorkloadStop"
	StormDaemon_WorkloadRemove_FullMethodName      = "/stormd.StormDaemon/WorkloadRemove"
	StormDaemon_WorkloadLogs_FullMethodName        = "/stormd.StormDaemon/WorkloadLogs"
	StormDaemon_NodeStatus_FullMethodName          = "/stormd.StormDaemon/NodeStatus"
	StormDaemon_ImagePull_FullMethodName           = "/stormd.StormDaemon/ImagePull"
	StormDaemon_ImageList_FullMethodName           = "/stormd.StormDaemon/ImageList"
	StormDaemon_WorkloadCreate_FullMethodName      = "/stormd.StormDaemon/WorkloadCreate"
	StormDaemon_NodeDrain_FullMethodName           = "/stormd.StormDaemon/NodeDrain"
	StormDaemon_NodeCordon_FullMethodName          = "/stormd.StormDaemon/NodeCordon"
	StormDaemon_NodeUncordon_FullMethodName        = "/stormd.StormDaemon/NodeUncordon"
	StormDaemon_ImageEnsure_FullMethodName         = "/stormd.StormDaemon/ImageEnsure"
	StormDaemon_MeshUpdate_FullMethodName          = "/stormd.StormDaemon/MeshUpdate"
	StormDaemon_ServiceUpdate_FullMethodName       = "/stormd.StormDaemon/ServiceUpdate"
	StormDaemon_ClusterStatus_FullMethodName       = "/stormd.StormDaemon/ClusterStatus"
	StormDaemon_NetworkPolicyApply_FullMethodName  = "/stormd.StormDaemon/NetworkPolicyApply"
	StormDaemon_NetworkPolicyDelete_FullMethodName = "/stormd.StormDaemon/NetworkPolicyDelete"
	StormDaemon_NetworkPolicyList_FullMethodName   = "/stormd.StormDaemon/NetworkPolicyList"
	StormDaemon_WorkloadCheckpoint_FullMethodName  = "/stormd.StormDaemon/WorkloadCheckpoint"
	StormDaemon_WorkloadRestore_FullMethodName     = "/stormd.StormDaemon/WorkloadRestore"
	StormDaemon_VmMigrate_FullMethodName           = "/stormd.StormDaemon/VmMigrate"
	StormDaemon_VmSnapshot_FullMethodName          = "/stormd.StormDaemon/VmSnapshot"
	StormDaemon_DeviceList_FullMethodName          = "/stormd.StormDaemon/DeviceList"
	StormDaemon_DeviceGet_FullMethodName           = "/stormd.StormDaemon/DeviceGet"
	StormDaemon_DeviceDiscover_FullMethodName      = "/stormd.StormDaemon/DeviceDiscover"
	StormDaemon_DeviceBind_FullMethodName          = "/stormd.StormDaemon/DeviceBind"
	StormDaemon_DeviceUnbind_FullMethodName        = "/stormd.StormDaemon/DeviceUnbind"
	StormDaemon_DeviceClassList_FullMethodName     = "/stormd.StormDaemon/DeviceClassList"
	StormDaemon_DeviceClassCreate_FullMethodName   = "/stormd.StormDaemon/DeviceClassCreate"
	StormDaemon_DeviceClassDelete_FullMethodName   = "/stormd.StormDaemon/DeviceClassDelete"
	StormDaemon_DeviceAllocate_FullMethodName      = "/stormd.StormDaemon/DeviceAllocate"
	StormDaemon_DeviceRelease_FullMethodName       = "/stormd.StormDaemon/DeviceRelease"
)

// StormDaemonClient is the client API for StormDaemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StormDaemonClient interface {
	// Workload lifecycle
	WorkloadList(ctx context.Context, in *WorkloadListRequest, opts ...grpc.CallOption) (*WorkloadListResponse, error)
	WorkloadStart(ctx context.Context, in *WorkloadActionRequest, opts ...grpc.CallOption) (*WorkloadActionResponse, error)
	WorkloadStop(ctx context.Context, in *WorkloadActionRequest, opts ...grpc.CallOption) (*WorkloadActionResponse, error)
	WorkloadRemove(ctx context.Context, in *WorkloadActionRequest, opts ...grpc.CallOption) (*WorkloadActionResponse, error)
	WorkloadLogs(ctx context.Context, in *WorkloadLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error)
	// Node operations
	NodeStatus(ctx context.Context, in *NodeStatusRequest, opts ...grpc.CallOption) (*NodeStatusResponse, error)
	// Image operations
	ImagePull(ctx context.Context, in *ImagePullRequest, opts ...grpc.CallOption) (*ImagePullResponse, error)
	ImageList(ctx context.Context, in *ImageListRequest, opts ...grpc.CallOption) (*ImageListResponse, error)
	// Cluster operations (mkube → stormd over WireGuard gRPC)
	WorkloadCreate(ctx context.Context, in *WorkloadCreateRequest, opts ...grpc.CallOption) (*WorkloadActionResponse, error)
	NodeDrain(ctx context.Context, in *NodeDrainRequest, opts ...grpc.CallOption) (*NodeDrainResponse, error)
	NodeCordon(ctx context.Context, in *NodeCordonRequest, opts ...grpc.CallOption) (*NodeCordonResponse, error)
	NodeUncordon(ctx context.Context, in *NodeCordonRequest, opts ...grpc.CallOption) (*NodeCordonResponse, error)
	ImageEnsure(ctx context.Context, in *ImageEnsureRequest, opts ...grpc.CallOption) (*ImageEnsureResponse, error)
	MeshUpdate(ctx context.Context, in *MeshUpdateRequest, opts ...grpc.CallOption) (*MeshUpdateResponse, error)
	ServiceUpdate(ctx context.Context, in *ServiceUpdateRequest, opts ...grpc.CallOption) (*ServiceUpdateResponse, error)
	ClusterStatus(ctx context.Context, in *ClusterStatusRequest, opts ...grpc.CallOption) (*ClusterStatusResponse, error)
	// Network policy operations
	NetworkPolicyApply(ctx context.Context, in *NetworkPolicyApplyRequest, opts ...grpc.CallOption) (*NetworkPolicyApplyResponse, error)
	NetworkPolicyDelete(ctx context.Context, in *NetworkPolicyDeleteRequest, opts ...grpc.CallOption) (*NetworkPolicyDeleteResponse, error)
	NetworkPolicyList(ctx context.Context, in *NetworkPolicyListRequest, opts ...grpc.CallOption) (*NetworkPolicyListResponse, error)
	// Migration operations (CRIU checkpoint/restore)
	WorkloadCheckpoint(ctx context.Context, in *WorkloadCheckpointRequest, opts ...grpc.CallOption) (*WorkloadCheckpointResponse, error)
	WorkloadRestore(ctx context.Context, in *WorkloadRestoreRequest, opts ...grpc.CallOption) (*WorkloadRestoreResponse, error)
	// VM operations (Cloud Hypervisor)
	VmMigrate(ctx context.Context, in *VmMigrateRequest, opts ...grpc.CallOption) (*VmMigrateResponse, error)
	VmSnapshot(ctx context.Context, in *VmSnapshotRequest, opts ...grpc.CallOption) (*VmSnapshotResponse, error)
	// Device passthrough operations
	DeviceList(ctx context.Context, in *DeviceListRequest, opts ...grpc.CallOption) (*DeviceListResponse, error)
	DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error)
	DeviceDiscover(ctx context.Context, in *DeviceDiscoverRequest, opts ...grpc.CallOption) (*DeviceDiscoverResponse, error)
	DeviceBind(ctx context.Context, in *DeviceBindRequest, opts ...grpc.CallOption) (*DeviceBindResponse, error)
	DeviceUnbind(ctx context.Context, in *DeviceUnbindRequest, opts ...grpc.CallOption) (*DeviceUnbindResponse, error)
	DeviceClassList(ctx context.Context, in *DeviceClassListRequest, opts ...grpc.CallOption) (*DeviceClassListResponse, error)
	DeviceClassCreate(ctx context.Context, in *DeviceClassCreateRequest, opts ...grpc.CallOption) (*DeviceClassCreateResponse, error)
	DeviceClassDelete(ctx context.Context, in *DeviceClassDeleteRequest, opts ...grpc.CallOption) (*DeviceClassDeleteResponse, error)
	DeviceAllocate(ctx context.Context, in *DeviceAllocateRequest, opts ...grpc.CallOption) (*DeviceAllocateResponse, error)
	DeviceRelease(ctx context.Context, in *DeviceReleaseRequest, opts ...grpc.CallOption) (*DeviceReleaseResponse, error)
}

type stormDaemonClient struct {
	cc grpc.ClientConnInterface
}

func NewStormDaemonClient(cc grpc.ClientConnInterface) StormDaemonClient {
	return &stormDaemonClient{cc}
}

func (c *stormDaemonClient) WorkloadList(ctx context.Context, in *WorkloadListRequest, opts ...grpc.CallOption) (*WorkloadListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkloadListResponse)
	err := c.cc.Invoke(ctx, StormDaemon_WorkloadList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) WorkloadStart(ctx context.Context, in *WorkloadActionRequest, opts ...grpc.CallOption) (*WorkloadActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkloadActionResponse)
	err := c.cc.Invoke(ctx, StormDaemon_WorkloadStart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) WorkloadStop(ctx context.Context, in *WorkloadActionRequest, opts ...grpc.CallOption) (*WorkloadActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkloadActionResponse)
	err := c.cc.Invoke(ctx, StormDaemon_WorkloadStop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) WorkloadRemove(ctx context.Context, in *WorkloadActionRequest, opts ...grpc.CallOption) (*WorkloadActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkloadActionResponse)
	err := c.cc.Invoke(ctx, StormDaemon_WorkloadRemove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) WorkloadLogs(ctx context.Context, in *WorkloadLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StormDaemon_ServiceDesc.Streams[0], StormDaemon_WorkloadLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WorkloadLogsRequest, LogEntry]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StormDaemon_WorkloadLogsClient = grpc.ServerStreamingClient[LogEntry]

func (c *stormDaemonClient) NodeStatus(ctx context.Context, in *NodeStatusRequest, opts ...grpc.CallOption) (*NodeStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeStatusResponse)
	err := c.cc.Invoke(ctx, StormDaemon_NodeStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) ImagePull(ctx context.Context, in *ImagePullRequest, opts ...grpc.CallOption) (*ImagePullResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImagePullResponse)
	err := c.cc.Invoke(ctx, StormDaemon_ImagePull_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) ImageList(ctx context.Context, in *ImageListRequest, opts ...grpc.CallOption) (*ImageListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImageListResponse)
	err := c.cc.Invoke(ctx, StormDaemon_ImageList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) WorkloadCreate(ctx context.Context, in *WorkloadCreateRequest, opts ...grpc.CallOption) (*WorkloadActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkloadActionResponse)
	err := c.cc.Invoke(ctx, StormDaemon_WorkloadCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) NodeDrain(ctx context.Context, in *NodeDrainRequest, opts ...grpc.CallOption) (*NodeDrainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeDrainResponse)
	err := c.cc.Invoke(ctx, StormDaemon_NodeDrain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) NodeCordon(ctx context.Context, in *NodeCordonRequest, opts ...grpc.CallOption) (*NodeCordonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeCordonResponse)
	err := c.cc.Invoke(ctx, StormDaemon_NodeCordon_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) NodeUncordon(ctx context.Context, in *NodeCordonRequest, opts ...grpc.CallOption) (*NodeCordonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeCordonResponse)
	err := c.cc.Invoke(ctx, StormDaemon_NodeUncordon_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) ImageEnsure(ctx context.Context, in *ImageEnsureRequest, opts ...grpc.CallOption) (*ImageEnsureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImageEnsureResponse)
	err := c.cc.Invoke(ctx, StormDaemon_ImageEnsure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) MeshUpdate(ctx context.Context, in *MeshUpdateRequest, opts ...grpc.CallOption) (*MeshUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MeshUpdateResponse)
	err := c.cc.Invoke(ctx, StormDaemon_MeshUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) ServiceUpdate(ctx context.Context, in *ServiceUpdateRequest, opts ...grpc.CallOption) (*ServiceUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceUpdateResponse)
	err := c.cc.Invoke(ctx, StormDaemon_ServiceUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) ClusterStatus(ctx context.Context, in *ClusterStatusRequest, opts ...grpc.CallOption) (*ClusterStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterStatusResponse)
	err := c.cc.Invoke(ctx, StormDaemon_ClusterStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) NetworkPolicyApply(ctx context.Context, in *NetworkPolicyApplyRequest, opts ...grpc.CallOption) (*NetworkPolicyApplyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NetworkPolicyApplyResponse)
	err := c.cc.Invoke(ctx, StormDaemon_NetworkPolicyApply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) NetworkPolicyDelete(ctx context.Context, in *NetworkPolicyDeleteRequest, opts ...grpc.CallOption) (*NetworkPolicyDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NetworkPolicyDeleteResponse)
	err := c.cc.Invoke(ctx, StormDaemon_NetworkPolicyDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) NetworkPolicyList(ctx context.Context, in *NetworkPolicyListRequest, opts ...grpc.CallOption) (*NetworkPolicyListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NetworkPolicyListResponse)
	err := c.cc.Invoke(ctx, StormDaemon_NetworkPolicyList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) WorkloadCheckpoint(ctx context.Context, in *WorkloadCheckpointRequest, opts ...grpc.CallOption) (*WorkloadCheckpointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkloadCheckpointResponse)
	err := c.cc.Invoke(ctx, StormDaemon_WorkloadCheckpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) WorkloadRestore(ctx context.Context, in *WorkloadRestoreRequest, opts ...grpc.CallOption) (*WorkloadRestoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkloadRestoreResponse)
	err := c.cc.Invoke(ctx, StormDaemon_WorkloadRestore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) VmMigrate(ctx context.Context, in *VmMigrateRequest, opts ...grpc.CallOption) (*VmMigrateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VmMigrateResponse)
	err := c.cc.Invoke(ctx, StormDaemon_VmMigrate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) VmSnapshot(ctx context.Context, in *VmSnapshotRequest, opts ...grpc.CallOption) (*VmSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VmSnapshotResponse)
	err := c.cc.Invoke(ctx, StormDaemon_VmSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceList(ctx context.Context, in *DeviceListRequest, opts ...grpc.CallOption) (*DeviceListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceListResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceGetResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceDiscover(ctx context.Context, in *DeviceDiscoverRequest, opts ...grpc.CallOption) (*DeviceDiscoverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceDiscoverResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceDiscover_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceBind(ctx context.Context, in *DeviceBindRequest, opts ...grpc.CallOption) (*DeviceBindResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceBindResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceBind_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceUnbind(ctx context.Context, in *DeviceUnbindRequest, opts ...grpc.CallOption) (*DeviceUnbindResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceUnbindResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceUnbind_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceClassList(ctx context.Context, in *DeviceClassListRequest, opts ...grpc.CallOption) (*DeviceClassListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceClassListResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceClassList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceClassCreate(ctx context.Context, in *DeviceClassCreateRequest, opts ...grpc.CallOption) (*DeviceClassCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceClassCreateResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceClassCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceClassDelete(ctx context.Context, in *DeviceClassDeleteRequest, opts ...grpc.CallOption) (*DeviceClassDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceClassDeleteResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceClassDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceAllocate(ctx context.Context, in *DeviceAllocateRequest, opts ...grpc.CallOption) (*DeviceAllocateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceAllocateResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceAllocate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stormDaemonClient) DeviceRelease(ctx context.Context, in *DeviceReleaseRequest, opts ...grpc.CallOption) (*DeviceReleaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceReleaseResponse)
	err := c.cc.Invoke(ctx, StormDaemon_DeviceRelease_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StormDaemonServer is the server API for StormDaemon service.
// All implementations must embed UnimplementedStormDaemonServer
// for forward compatibility.
type StormDaemonServer interface {
	// Workload lifecycle
	WorkloadList(context.Context, *WorkloadListRequest) (*WorkloadListResponse, error)
	WorkloadStart(context.Context, *WorkloadActionRequest) (*WorkloadActionResponse, error)
	WorkloadStop(context.Context, *WorkloadActionRequest) (*WorkloadActionResponse, error)
	WorkloadRemove(context.Context, *WorkloadActionRequest) (*WorkloadActionResponse, error)
	WorkloadLogs(*WorkloadLogsRequest, grpc.ServerStreamingServer[LogEntry]) error
	// Node operations
	NodeStatus(context.Context, *NodeStatusRequest) (*NodeStatusResponse, error)
	// Image operations
	ImagePull(context.Context, *ImagePullRequest) (*ImagePullResponse, error)
	ImageList(context.Context, *ImageListRequest) (*ImageListResponse, error)
	// Cluster operations (mkube → stormd over WireGuard gRPC)
	WorkloadCreate(context.Context, *WorkloadCreateRequest) (*WorkloadActionResponse, error)
	NodeDrain(context.Context, *NodeDrainRequest) (*NodeDrainResponse, error)
	NodeCordon(context.Context, *NodeCordonRequest) (*NodeCordonResponse, error)
	NodeUncordon(context.Context, *NodeCordonRequest) (*NodeCordonResponse, error)
	ImageEnsure(context.Context, *ImageEnsureRequest) (*ImageEnsureResponse, error)
	MeshUpdate(context.Context, *MeshUpdateRequest) (*MeshUpdateResponse, error)
	ServiceUpdate(context.Context, *ServiceUpdateRequest) (*ServiceUpdateResponse, error)
	ClusterStatus(context.Context, *ClusterStatusRequest) (*ClusterStatusResponse, error)
	// Network policy operations
	NetworkPolicyApply(context.Context, *NetworkPolicyApplyRequest) (*NetworkPolicyApplyResponse, error)
	NetworkPolicyDelete(context.Context, *NetworkPolicyDeleteRequest) (*NetworkPolicyDeleteResponse, error)
	NetworkPolicyList(context.Context, *NetworkPolicyListRequest) (*NetworkPolicyListResponse, error)
	// Migration operations (CRIU checkpoint/restore)
	WorkloadCheckpoint(context.Context, *WorkloadCheckpointRequest) (*WorkloadCheckpointResponse, error)
	WorkloadRestore(context.Context, *WorkloadRestoreRequest) (*WorkloadRestoreResponse, error)
	// VM operations (Cloud Hypervisor)
	VmMigrate(context.Context, *VmMigrateRequest) (*VmMigrateResponse, error)
	VmSnapshot(context.Context, *VmSnapshotRequest) (*VmSnapshotResponse, error)
	// Device passthrough operations
	DeviceList(context.Context, *DeviceListRequest) (*DeviceListResponse, error)
	DeviceGet(context.Context, *DeviceGetRequest) (*DeviceGetResponse, error)
	DeviceDiscover(context.Context, *DeviceDiscoverRequest) (*DeviceDiscoverResponse, error)
	DeviceBind(context.Context, *DeviceBindRequest) (*DeviceBindResponse, error)
	DeviceUnbind(context.Context, *DeviceUnbindRequest) (*DeviceUnbindResponse, error)
	DeviceClassList(context.Context, *DeviceClassListRequest) (*DeviceClassListResponse, error)
	DeviceClassCreate(context.Context, *DeviceClassCreateRequest) (*DeviceClassCreateResponse, error)
	DeviceClassDelete(context.Context, *DeviceClassDeleteRequest) (*DeviceClassDeleteResponse, error)
	DeviceAllocate(context.Context, *DeviceAllocateRequest) (*DeviceAllocateResponse, error)
	DeviceRelease(context.Context, *DeviceReleaseRequest) (*DeviceReleaseResponse, error)
	mustEmbedUnimplementedStormDaemonServer()
}

// UnimplementedStormDaemonServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStormDaemonServer struct{}

func (UnimplementedStormDaemonServer) WorkloadList(context.Context, *WorkloadListRequest) (*WorkloadListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WorkloadList not implemented")
}
func (UnimplementedStormDaemonServer) WorkloadStart(context.Context, *WorkloadActionRequest) (*WorkloadActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WorkloadStart not implemented")
}
func (UnimplementedStormDaemonServer) WorkloadStop(context.Context, *WorkloadActionRequest) (*WorkloadActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WorkloadStop not implemented")
}
func (UnimplementedStormDaemonServer) WorkloadRemove(context.Context, *WorkloadActionRequest) (*WorkloadActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WorkloadRemove not implemented")
}
func (UnimplementedStormDaemonServer) WorkloadLogs(*WorkloadLogsRequest, grpc.ServerStreamingServer[LogEntry]) error {
	return status.Error(codes.Unimplemented, "method WorkloadLogs not implemented")
}
func (UnimplementedStormDaemonServer) NodeStatus(context.Context, *NodeStatusRequest) (*NodeStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NodeStatus not implemented")
}
func (UnimplementedStormDaemonServer) ImagePull(context.Context, *ImagePullRequest) (*ImagePullResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ImagePull not implemented")
}
func (UnimplementedStormDaemonServer) ImageList(context.Context, *ImageListRequest) (*ImageListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ImageList not implemented")
}
func (UnimplementedStormDaemonServer) WorkloadCreate(context.Context, *WorkloadCreateRequest) (*WorkloadActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WorkloadCreate not implemented")
}
func (UnimplementedStormDaemonServer) NodeDrain(context.Context, *NodeDrainRequest) (*NodeDrainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NodeDrain not implemented")
}
func (UnimplementedStormDaemonServer) NodeCordon(context.Context, *NodeCordonRequest) (*NodeCordonResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NodeCordon not implemented")
}
func (UnimplementedStormDaemonServer) NodeUncordon(context.Context, *NodeCordonRequest) (*NodeCordonResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NodeUncordon not implemented")
}
func (UnimplementedStormDaemonServer) ImageEnsure(context.Context, *ImageEnsureRequest) (*ImageEnsureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ImageEnsure not implemented")
}
func (UnimplementedStormDaemonServer) MeshUpdate(context.Context, *MeshUpdateRequest) (*MeshUpdateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MeshUpdate not implemented")
}
func (UnimplementedStormDaemonServer) ServiceUpdate(context.Context, *ServiceUpdateRequest) (*ServiceUpdateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ServiceUpdate not implemented")
}
func (UnimplementedStormDaemonServer) ClusterStatus(context.Context, *ClusterStatusRequest) (*ClusterStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClusterStatus not implemented")
}
func (UnimplementedStormDaemonServer) NetworkPolicyApply(context.Context, *NetworkPolicyApplyRequest) (*NetworkPolicyApplyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NetworkPolicyApply not implemented")
}
func (UnimplementedStormDaemonServer) NetworkPolicyDelete(context.Context, *NetworkPolicyDeleteRequest) (*NetworkPolicyDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NetworkPolicyDelete not implemented")
}
func (UnimplementedStormDaemonServer) NetworkPolicyList(context.Context, *NetworkPolicyListRequest) (*NetworkPolicyListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NetworkPolicyList not implemented")
}
func (UnimplementedStormDaemonServer) WorkloadCheckpoint(context.Context, *WorkloadCheckpointRequest) (*WorkloadCheckpointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WorkloadCheckpoint not implemented")
}
func (UnimplementedStormDaemonServer) WorkloadRestore(context.Context, *WorkloadRestoreRequest) (*WorkloadRestoreResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WorkloadRestore not implemented")
}
func (UnimplementedStormDaemonServer) VmMigrate(context.Context, *VmMigrateRequest) (*VmMigrateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VmMigrate not implemented")
}
func (UnimplementedStormDaemonServer) VmSnapshot(context.Context, *VmSnapshotRequest) (*VmSnapshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VmSnapshot not implemented")
}
func (UnimplementedStormDaemonServer) DeviceList(context.Context, *DeviceListRequest) (*DeviceListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceList not implemented")
}
func (UnimplementedStormDaemonServer) DeviceGet(context.Context, *DeviceGetRequest) (*DeviceGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceGet not implemented")
}
func (UnimplementedStormDaemonServer) DeviceDiscover(context.Context, *DeviceDiscoverRequest) (*DeviceDiscoverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceDiscover not implemented")
}
func (UnimplementedStormDaemonServer) DeviceBind(context.Context, *DeviceBindRequest) (*DeviceBindResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceBind not implemented")
}
func (UnimplementedStormDaemonServer) DeviceUnbind(context.Context, *DeviceUnbindRequest) (*DeviceUnbindResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceUnbind not implemented")
}
func (UnimplementedStormDaemonServer) DeviceClassList(context.Context, *DeviceClassListRequest) (*DeviceClassListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceClassList not implemented")
}
func (UnimplementedStormDaemonServer) DeviceClassCreate(context.Context, *DeviceClassCreateRequest) (*DeviceClassCreateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceClassCreate not implemented")
}
func (UnimplementedStormDaemonServer) DeviceClassDelete(context.Context, *DeviceClassDeleteRequest) (*DeviceClassDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceClassDelete not implemented")
}
func (UnimplementedStormDaemonServer) DeviceAllocate(context.Context, *DeviceAllocateRequest) (*DeviceAllocateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceAllocate not implemented")
}
func (UnimplementedStormDaemonServer) DeviceRelease(context.Context, *DeviceReleaseRequest) (*DeviceReleaseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeviceRelease not implemented")
}
func (UnimplementedStormDaemonServer) mustEmbedUnimplementedStormDaemonServer() {}
func (UnimplementedStormDaemonServer) testEmbeddedByValue()                     {}

// UnsafeStormDaemonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StormDaemonServer will
// result in compilation errors.
type UnsafeStormDaemonServer interface {
	mustEmbedUnimplementedStormDaemonServer()
}

func RegisterStormDaemonServer(s grpc.ServiceRegistrar, srv StormDaemonServer) {
	// If the following call panics, it indicates UnimplementedStormDaemonServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StormDaemon_ServiceDesc, srv)
}

func _StormDaemon_WorkloadList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).WorkloadList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_WorkloadList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).WorkloadList(ctx, req.(*WorkloadListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_WorkloadStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).WorkloadStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_WorkloadStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).WorkloadStart(ctx, req.(*WorkloadActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_WorkloadStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).WorkloadStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_WorkloadStop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).WorkloadStop(ctx, req.(*WorkloadActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_WorkloadRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).WorkloadRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_WorkloadRemove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).WorkloadRemove(ctx, req.(*WorkloadActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_WorkloadLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WorkloadLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StormDaemonServer).WorkloadLogs(m, &grpc.GenericServerStream[WorkloadLogsRequest, LogEntry]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StormDaemon_WorkloadLogsServer = grpc.ServerStreamingServer[LogEntry]

func _StormDaemon_NodeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).NodeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_NodeStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).NodeStatus(ctx, req.(*NodeStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_ImagePull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImagePullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).ImagePull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_ImagePull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).ImagePull(ctx, req.(*ImagePullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_ImageList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).ImageList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_ImageList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).ImageList(ctx, req.(*ImageListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_WorkloadCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).WorkloadCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_WorkloadCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).WorkloadCreate(ctx, req.(*WorkloadCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_NodeDrain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeDrainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).NodeDrain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_NodeDrain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).NodeDrain(ctx, req.(*NodeDrainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_NodeCordon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeCordonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).NodeCordon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_NodeCordon_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).NodeCordon(ctx, req.(*NodeCordonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_NodeUncordon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeCordonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).NodeUncordon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_NodeUncordon_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).NodeUncordon(ctx, req.(*NodeCordonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_ImageEnsure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageEnsureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).ImageEnsure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_ImageEnsure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).ImageEnsure(ctx, req.(*ImageEnsureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_MeshUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MeshUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).MeshUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_MeshUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).MeshUpdate(ctx, req.(*MeshUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_ServiceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).ServiceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_ServiceUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).ServiceUpdate(ctx, req.(*ServiceUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_ClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).ClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_ClusterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).ClusterStatus(ctx, req.(*ClusterStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_NetworkPolicyApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkPolicyApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).NetworkPolicyApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_NetworkPolicyApply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).NetworkPolicyApply(ctx, req.(*NetworkPolicyApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_NetworkPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkPolicyDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).NetworkPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_NetworkPolicyDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).NetworkPolicyDelete(ctx, req.(*NetworkPolicyDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_NetworkPolicyList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkPolicyListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).NetworkPolicyList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_NetworkPolicyList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).NetworkPolicyList(ctx, req.(*NetworkPolicyListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_WorkloadCheckpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadCheckpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).WorkloadCheckpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_WorkloadCheckpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).WorkloadCheckpoint(ctx, req.(*WorkloadCheckpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_WorkloadRestore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadRestoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).WorkloadRestore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_WorkloadRestore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).WorkloadRestore(ctx, req.(*WorkloadRestoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_VmMigrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VmMigrateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).VmMigrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_VmMigrate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).VmMigrate(ctx, req.(*VmMigrateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_VmSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VmSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).VmSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_VmSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).VmSnapshot(ctx, req.(*VmSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceList(ctx, req.(*DeviceListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceGet(ctx, req.(*DeviceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceDiscover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceDiscoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceDiscover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceDiscover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceDiscover(ctx, req.(*DeviceDiscoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceBind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceBindRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceBind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceBind_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceBind(ctx, req.(*DeviceBindRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceUnbind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceUnbindRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceUnbind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceUnbind_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceUnbind(ctx, req.(*DeviceUnbindRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceClassList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceClassListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceClassList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceClassList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceClassList(ctx, req.(*DeviceClassListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceClassCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceClassCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceClassCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceClassCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceClassCreate(ctx, req.(*DeviceClassCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceClassDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceClassDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceClassDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceClassDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceClassDelete(ctx, req.(*DeviceClassDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceAllocate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceAllocateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceAllocate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceAllocate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceAllocate(ctx, req.(*DeviceAllocateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StormDaemon_DeviceRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StormDaemonServer).DeviceRelease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StormDaemon_DeviceRelease_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StormDaemonServer).DeviceRelease(ctx, req.(*DeviceReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StormDaemon_ServiceDesc is the grpc.ServiceDesc for StormDaemon service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StormDaemon_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stormd.StormDaemon",
	HandlerType: (*StormDaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WorkloadList",
			Handler:    _StormDaemon_WorkloadList_Handler,
		},
		{
			MethodName: "WorkloadStart",
			Handler:    _StormDaemon_WorkloadStart_Handler,
		},
		{
			MethodName: "WorkloadStop",
			Handler:    _StormDaemon_WorkloadStop_Handler,
		},
		{
			MethodName: "WorkloadRemove",
			Handler:    _StormDaemon_WorkloadRemove_Handler,
		},
		{
			MethodName: "NodeStatus",
			Handler:    _StormDaemon_NodeStatus_Handler,
		},
		{
			MethodName: "ImagePull",
			Handler:    _StormDaemon_ImagePull_Handler,
		},
		{
			MethodName: "ImageList",
			Handler:    _StormDaemon_ImageList_Handler,
		},
		{
			MethodName: "WorkloadCreate",
			Handler:    _StormDaemon_WorkloadCreate_Handler,
		},
		{
			MethodName: "NodeDrain",
			Handler:    _StormDaemon_NodeDrain_Handler,
		},
		{
			MethodName: "NodeCordon",
			Handler:    _StormDaemon_NodeCordon_Handler,
		},
		{
			MethodName: "NodeUncordon",
			Handler:    _StormDaemon_NodeUncordon_Handler,
		},
		{
			MethodName: "ImageEnsure",
			Handler:    _StormDaemon_ImageEnsure_Handler,
		},
		{
			MethodName: "MeshUpdate",
			Handler:    _StormDaemon_MeshUpdate_Handler,
		},
		{
			MethodName: "ServiceUpdate",
			Handler:    _StormDaemon_ServiceUpdate_Handler,
		},
		{
			MethodName: "ClusterStatus",
			Handler:    _StormDaemon_ClusterStatus_Handler,
		},
		{
			MethodName: "NetworkPolicyApply",
			Handler:    _StormDaemon_NetworkPolicyApply_Handler,
		},
		{
			MethodName: "NetworkPolicyDelete",
			Handler:    _StormDaemon_NetworkPolicyDelete_Handler,
		},
		{
			MethodName: "NetworkPolicyList",
			Handler:    _StormDaemon_NetworkPolicyList_Handler,
		},
		{
			MethodName: "WorkloadCheckpoint",
			Handler:    _StormDaemon_WorkloadCheckpoint_Handler,
		},
		{
			MethodName: "WorkloadRestore",
			Handler:    _StormDaemon_WorkloadRestore_Handler,
		},
		{
			MethodName: "VmMigrate",
			Handler:    _StormDaemon_VmMigrate_Handler,
		},
		{
			MethodName: "VmSnapshot",
			Handler:    _StormDaemon_VmSnapshot_Handler,
		},
		{
			MethodName: "DeviceList",
			Handler:    _StormDaemon_DeviceList_Handler,
		},
		{
			MethodName: "DeviceGet",
			Handler:    _StormDaemon_DeviceGet_Handler,
		},
		{
			MethodName: "DeviceDiscover",
			Handler:    _StormDaemon_DeviceDiscover_Handler,
		},
		{
			MethodName: "DeviceBind",
			Handler:    _StormDaemon_DeviceBind_Handler,
		},
		{
			MethodName: "DeviceUnbind",
			Handler:    _StormDaemon_DeviceUnbind_Handler,
		},
		{
			MethodName: "DeviceClassList",
			Handler:    _StormDaemon_DeviceClassList_Handler,
		},
		{
			MethodName: "DeviceClassCreate",
			Handler:    _StormDaemon_DeviceClassCreate_Handler,
		},
		{
			MethodName: "DeviceClassDelete",
			Handler:    _StormDaemon_DeviceClassDelete_Handler,
		},
		{
			MethodName: "DeviceAllocate",
			Handler:    _StormDaemon_DeviceAllocate_Handler,
		},
		{
			MethodName: "DeviceRelease",
			Handler:    _StormDaemon_DeviceRelease_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WorkloadLogs",
			Handler:       _StormDaemon_WorkloadLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "stormd.proto",
}
